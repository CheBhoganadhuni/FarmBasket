{% extends 'base.html' %}

{% block title %}Checkout - FarmBasket{% endblock %}

{% block content %}
<div class="min-h-screen bg-gradient-to-br from-green-50 to-white py-12 px-4" x-data="checkoutPage()">
    <div class="container mx-auto max-w-7xl">

        <!-- Header -->
        <div class="mb-8">
            <h1 class="font-display text-4xl font-bold mb-2">üõí Checkout</h1>
            <p class="text-gray-600">Complete your order</p>
        </div>

        <!-- Loading -->
        <template x-if="loading">
            <div class="text-center py-20">
                <div class="text-6xl mb-4">‚è≥</div>
                <p class="text-xl">Loading checkout...</p>
            </div>
        </template>

        <!-- Checkout Form -->
        <template x-if="!loading && cart">
            <div class="relative">
                <!-- Processing Overlay -->
                <div x-show="placing" class="fixed inset-0 z-50 bg-black bg-opacity-70 flex items-center justify-center"
                    x-transition:enter="transition ease-out duration-300" x-transition:enter-start="opacity-0"
                    x-transition:enter-end="opacity-100">
                    <div class="bg-white dark:bg-gray-800 p-8 rounded-2xl shadow-2xl text-center max-w-sm mx-4">
                        <div class="mb-4 relative">
                            <div class="animate-spin rounded-full h-16 w-16 border-b-4 border-neon mx-auto"></div>
                            <div class="absolute inset-0 flex items-center justify-center text-xl">üß∫</div>
                        </div>
                        <h3 class="text-xl font-bold mb-2">Processing Order</h3>
                        <p class="text-gray-600 dark:text-gray-400">Please wait while we secure your organic goodies...
                        </p>
                        <p class="text-xs text-gray-500 mt-4">Do not refresh the page</p>
                    </div>
                </div>

                <form @submit.prevent="placeOrder" class="grid md:grid-cols-3 gap-6">

                    <!-- Left Column: Forms -->
                    <div class="md:col-span-2 space-y-6">

                        <!-- Delivery Address -->
                        <div class="glass rounded-xl p-6">
                            <div class="flex items-center justify-between mb-4">
                                <h2 class="font-display text-2xl font-bold">üìç Delivery Address</h2>

                                <!-- Use Location Button -->
                                <button type="button" @click="getLocation()" :disabled="fetchingLocation"
                                    class="text-sm px-3 py-1.5 bg-blue-100 text-blue-700 rounded-lg hover:bg-blue-200 transition font-semibold flex items-center gap-2"
                                    x-show="!selectedAddressId"> <!-- Only show when entering new address -->
                                    <span x-show="!fetchingLocation">üìç Use Current Location</span>
                                    <span x-show="fetchingLocation" class="flex items-center gap-1">
                                        <svg class="animate-spin h-3 w-3" xmlns="http://www.w3.org/2000/svg" fill="none"
                                            viewBox="0 0 24 24">
                                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor"
                                                stroke-width="4"></circle>
                                            <path class="opacity-75" fill="currentColor"
                                                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                                            </path>
                                        </svg>
                                        Locating...
                                    </span>
                                </button>
                            </div>

                            <!-- Saved Addresses -->
                            <div x-show="isAuthenticated && addresses.length > 0" class="mb-6">
                                <label class="block text-sm font-semibold mb-2">Choose saved address:</label>
                                <select x-model="selectedAddressId" @change="fillAddressFromSaved"
                                    class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-neon focus:outline-none">
                                    <option value="">Enter new address</option>
                                    <template x-for="addr in addresses" :key="addr.id">
                                        <option :value="addr.id"
                                            x-text="`${addr.label} - ${addr.street_address}, ${addr.city}`"></option>
                                    </template>
                                </select>
                            </div>


                            <!-- Address Form -->




                            <div class="grid md:grid-cols-2 gap-4">
                                <div>
                                    <label class="block text-sm font-semibold mb-2">Full Name *</label>
                                    <input type="text" x-model="address.name" @input="validateField('name')" required
                                        :class="{'border-red-500 bg-red-50': touched.name && errors.name, 'border-gray-300': !touched.name || !errors.name}"
                                        class="w-full px-4 py-2 border-2 rounded-lg focus:border-neon focus:outline-none transition-colors">
                                    <p x-show="touched.name && errors.name" x-text="errors.name"
                                        class="text-red-500 text-xs mt-1 font-semibold"></p>
                                </div>
                                <div>
                                    <label class="block text-sm font-semibold mb-2">Postal Code *</label>
                                    <div class="relative">
                                        <input type="text" x-model="address.postal_code"
                                            @input="address.postal_code = address.postal_code.replace(/[^0-9]/g, ''); validateField('postal_code')"
                                            required pattern="[0-9]{6}"
                                            :class="{'border-red-500 bg-red-50': touched.postal_code && errors.postal_code, 'border-gray-300': !touched.postal_code || !errors.postal_code}"
                                            class="w-full px-4 py-2 border-2 rounded-lg focus:border-neon focus:outline-none transition-colors"
                                            placeholder="6-digit pincode">
                                        <div x-show="fetchingPincode"
                                            class="absolute right-4 top-1/2 -translate-y-1/2 animate-spin text-neon">
                                            ‚è≥
                                        </div>
                                    </div>
                                    <p x-show="touched.postal_code && errors.postal_code" x-text="errors.postal_code"
                                        class="text-red-500 text-xs mt-1 font-semibold"></p>
                                    <p x-show="pincodeStatus" x-text="pincodeStatus"
                                        class="text-orange-500 text-xs mt-1 font-medium animate-pulse"></p>
                                </div>

                                <div class="md:col-span-2">
                                    <label class="block text-sm font-semibold mb-2">Address *</label>
                                    <textarea x-model="address.address" @input="validateField('address')" required
                                        rows="3"
                                        :class="{'border-red-500 bg-red-50': touched.address && errors.address, 'border-gray-300': !touched.address || !errors.address}"
                                        class="w-full px-4 py-2 border-2 rounded-lg focus:border-neon focus:outline-none transition-colors"></textarea>
                                    <p x-show="touched.address && errors.address" x-text="errors.address"
                                        class="text-red-500 text-xs mt-1 font-semibold"></p>
                                </div>

                                <div>
                                    <label class="block text-sm font-semibold mb-2">Post Office / Area *</label>

                                    <!-- Dropdown for Auto-Fetch -->
                                    <div x-show="cityOptions.length > 0">
                                        <select x-model="address.city" @change="validateField('city')"
                                            class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-neon focus:outline-none transition-colors bg-white appearance-auto text-black">
                                            <template x-for="option in cityOptions" :key="option">
                                                <option :value="option" x-text="option"></option>
                                            </template>
                                        </select>
                                    </div>

                                    <!-- Manual Input Fallback -->
                                    <div x-show="cityOptions.length === 0">
                                        <input type="text" x-model="address.city" @input="validateField('city')"
                                            required
                                            :class="{'border-red-500 bg-red-50': touched.city && errors.city, 'border-gray-300': !touched.city || !errors.city}"
                                            class="w-full px-4 py-2 border-2 rounded-lg focus:border-neon focus:outline-none transition-colors"
                                            :placeholder="fetchingPincode ? 'Loading...' : 'City Name'">
                                    </div>

                                    <p x-show="touched.city && errors.city" x-text="errors.city"
                                        class="text-red-500 text-xs mt-1 font-semibold"></p>
                                </div>
                                <div>
                                    <label class="block text-sm font-semibold mb-2">State *</label>
                                    <input type="text" x-model="address.state" @input="validateField('state')" required
                                        :class="{'border-red-500 bg-red-50': touched.state && errors.state, 'border-gray-300': !touched.state || !errors.state}"
                                        class="w-full px-4 py-2 border-2 rounded-lg focus:border-neon focus:outline-none transition-colors">
                                    <p x-show="touched.state && errors.state" x-text="errors.state"
                                        class="text-red-500 text-xs mt-1 font-semibold"></p>
                                </div>

                                <div>
                                    <label class="block text-sm font-semibold mb-2">Phone Number *</label>
                                    <input type="tel" x-model="address.phone"
                                        @input="address.phone = address.phone.replace(/[^0-9]/g, ''); validateField('phone')"
                                        required pattern="[0-9]{10}"
                                        :class="{'border-red-500 bg-red-50': touched.phone && errors.phone, 'border-gray-300': !touched.phone || !errors.phone}"
                                        class="w-full px-4 py-2 border-2 rounded-lg focus:border-neon focus:outline-none transition-colors">
                                    <p x-show="touched.phone && errors.phone" x-text="errors.phone"
                                        class="text-red-500 text-xs mt-1 font-semibold"></p>
                                </div>

                                <div>
                                    <label class="block text-sm font-semibold mb-2">Landmark (Optional)</label>
                                    <input type="text" x-model="address.landmark"
                                        class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-neon focus:outline-none transition-colors">
                                </div>
                            </div>
                        </div>

                        <!-- Payment Method -->
                        <div class="glass rounded-xl p-6" :class="{'opacity-50 pointer-events-none': !isFormValid}">
                            <h2 class="font-display text-2xl font-bold mb-4 flex justify-between">
                                <span>üí≥ Payment Method</span>
                                <span x-show="!isFormValid" class="text-xs text-red-500 font-normal self-center">Enter
                                    valid address to unlock</span>
                            </h2>

                            <div class="space-y-3">
                                <!-- Razorpay -->
                                <label
                                    class="flex items-center p-4 border-2 rounded-lg cursor-pointer transition select-none"
                                    :class="paymentMethod === 'RAZORPAY' ? 'border-neon' : 'border-gray-300 hover:bg-gray-50'">
                                    <input type="radio" x-model="paymentMethod" value="RAZORPAY" class="mr-3">
                                    <div>
                                        <div class="font-semibold">üí≥ Pay Online (Razorpay)</div>
                                        <div class="text-sm text-gray-600">UPI, Cards, Wallets, NetBanking</div>
                                        <div class="text-xs text-orange-500 mt-1" x-show="paymentMethod === 'RAZORPAY'">
                                            Razorpay payments are auto successed, use any upi id if needed viz,
                                            <b>success@razorpay</b>
                                        </div>
                                    </div>
                                </label>

                                <!-- COD -->
                                <label
                                    class="flex items-center p-4 border-2 rounded-lg cursor-pointer transition select-none"
                                    :class="paymentMethod === 'COD' ? 'border-neon' : 'border-gray-300 hover:bg-gray-50'">
                                    <input type="radio" x-model="paymentMethod" value="COD" class="mr-3">
                                    <div>
                                        <div class="font-semibold">üíµ Cash on Delivery</div>
                                        <div class="text-sm text-gray-600">Pay when you receive</div>
                                    </div>
                                </label>
                            </div>
                        </div>

                        <!-- Test Payment Info -->
                        <!-- <div x-show="useTestPayment" class="glass rounded-xl p-6 bg-blue-50 dark:bg-blue-900/20 border-2 border-blue-500"> -->
                        <!-- <h3 class="font-bold text-blue-800 dark:text-blue-400 mb-3">üß™ Test Payment Instructions</h3> -->
                        <!-- <div class="text-sm text-blue-700 dark:text-blue-300 space-y-2"> -->
                        <!-- <p class="font-semibold">Use these test credentials:</p> -->

                        <!-- <p class="mt-2"><strong>Test UPI:</strong> <code class="bg-white dark:bg-gray-800 px-2 py-1 rounded">success@razorpay</code></p> -->

                        <!-- <p class="text-red-600 dark:text-red-400 font-semibold mt-3">‚ö†Ô∏è Don't scan QR codes in test mode!</p> -->
                        <!-- </div> -->
                        <!-- </div> -->


                        <!-- Order Notes -->
                        <div class="glass rounded-xl p-6">
                            <h2 class="font-display text-2xl font-bold mb-4">üìù Order Notes (Optional)</h2>
                            <textarea x-model="orderNotes" rows="3" placeholder="Any special instructions..."
                                class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-neon focus:outline-none"></textarea>
                        </div>

                        <!-- ‚úÖ Test Payment Toggle -->
                        <!-- <div x-show="testModeEnabled" class="glass rounded-xl p-6 bg-yellow-50 border-2 border-yellow-500"> -->
                        <!-- <label class="flex items-center cursor-pointer"> -->
                        <!-- <input type="checkbox" x-model="useTestPayment" class="mr-3"> -->
                        <!-- <div> -->
                        <!-- <div class="font-semibold text-yellow-800">üß™ Test Payment Mode (‚Çπ1 Only)</div> -->
                        <!-- <div class="text-sm text-yellow-700">Enable this to test with ‚Çπ1 payment instead of full amount</div> -->
                        <!-- </div> -->
                        <!-- </label> -->
                        <!-- </div> -->
                    </div>

                    <!-- Right Column: Order Summary -->
                    <div class="glass rounded-xl p-6 h-fit sticky top-24">
                        <h2 class="font-display text-2xl font-bold mb-6">Order Summary</h2>

                        <!-- Items -->
                        <div class="space-y-3 mb-6 max-h-60 overflow-y-auto">
                            <template x-for="item in cart.items" :key="item.id">
                                <div class="flex gap-3">
                                    <a :href="`/products/${item.product_slug}/`"
                                        class="w-16 h-16 bg-gray-100 rounded-lg overflow-hidden flex-shrink-0 block hover:opacity-80 transition">
                                        <img x-show="item.product_image" :src="item.product_image"
                                            :alt="item.product_name" class="w-full h-full object-cover">
                                    </a>
                                    <div class="flex-1">
                                        <div class="font-semibold text-sm line-clamp-1" x-text="item.product_name">
                                        </div>
                                        <div class="text-sm text-gray-600">Qty: <span x-text="item.quantity"></span>
                                        </div>
                                        <div class="font-bold text-neon">‚Çπ<span x-text="item.total_price"></span></div>
                                    </div>
                                </div>
                            </template>
                        </div>

                        <!-- Pricing -->
                        <div class="space-y-3 border-t pt-4">
                            <div class="flex justify-between text-gray-600">
                                <span>Subtotal</span>
                                <span>‚Çπ<span x-text="cart.subtotal"></span></span>
                            </div>
                            <div class="flex justify-between text-gray-600">
                                <span>Delivery</span>
                                <span x-show="deliveryCharge > 0">‚Çπ<span x-text="deliveryCharge"></span></span>
                                <span x-show="deliveryCharge === 0" class="text-green-600">FREE</span>
                            </div>
                            <div class="flex justify-between text-gray-600">
                                <span>Processing Fee Of ‚Çπ1 Mandatory</span>
                            </div>
                            <!-- <div x-show="useTestPayment" class="flex justify-between text-yellow-600"> -->
                            <!-- <span>Test Discount</span> -->
                            <!-- <span>-‚Çπ<span x-text="(parseFloat(cart.subtotal) + deliveryCharge - 1).toFixed(2)"></span></span> -->
                            <!-- </div> -->
                            <div x-show="useWallet" class="flex justify-between text-green-600">
                                <span>Wallet Deduction</span>
                                <span>-‚Çπ<span x-text="walletDeduction.toFixed(2)"></span></span>
                            </div>
                            <div class="border-t pt-3 flex justify-between font-bold text-xl">
                                <span>Total</span>
                                <span class="text-neon">‚Çπ<span x-text="payableAmount"></span></span>
                            </div>
                        </div>

                        <!-- Wallet Balance and Use Wallet -->
                        <div class="glass rounded-xl p-6 mb-6" x-show="isAuthenticated">
                            <h3 class="font-semibold mb-2">Wallet</h3>
                            <p>Available balance: ‚Çπ <span x-text="walletBalance.toFixed(2)"></span></p>
                            <label class="inline-flex items-center mt-2">
                                <input type="checkbox" x-model="useWallet"
                                    class="form-checkbox h-5 w-5 text-green-500" />
                                <span class="ml-2">Use wallet balance for this order</span>
                            </label>
                        </div>


                        <!-- Place Order Button -->
                        <!-- Place Order Button -->
                        <div x-show="isAuthenticated">
                            <button type="submit" :disabled="placing"
                                class="w-full mt-6 px-6 py-4 bg-neon text-white rounded-lg hover:bg-green-600 transition font-semibold text-lg disabled:opacity-50">
                                <span x-show="!placing">Place Order üöÄ</span>
                                <span x-show="placing">Processing, Do Not Click Anything...</span>
                            </button>
                        </div>
                        <div x-show="!isAuthenticated" class="mt-6 space-y-3">
                            <button type="button" :disabled="!isFormValid" @click="
                                localStorage.setItem('need_checkout', 'true');
                                // ‚úÖ Save Guest Address with Empty String Defaults for Optional Fields
                                const guestAddress = {
                                    label: 'Guest',
                                    address_type: 'HOME',
                                    street_address: address.address,
                                    city: address.city,
                                    state: address.state,
                                    postal_code: address.postal_code,
                                    phone: address.phone,
                                    apartment: address.apartment || '',  // ‚úÖ Force empty string if undefined/null
                                    landmark: address.landmark || '',    // ‚úÖ Force empty string if undefined/null
                                    is_default: true
                                };
                                localStorage.setItem('guest_address', JSON.stringify(guestAddress));
                                window.location.href = '/auth/login/?next=/checkout/';
                             "
                                class="w-full px-6 py-4 bg-neon text-white rounded-lg hover:bg-green-600 transition font-semibold text-lg disabled:opacity-50 disabled:cursor-not-allowed">
                                <span x-show="isFormValid">Login to Place Order</span>
                                <span x-show="!isFormValid">Fill Address to Login & Order</span>
                            </button>
                            <p class="text-xs text-center text-gray-500">
                                You need to login or sign up to complete your purchase. Your cart will be saved!
                            </p>
                        </div>
                        <p class="text-xs text-center text-gray-500 mt-3 px-2">
                            Confirmation email will be sent once order is confirmed. Please check your spam folder too!
                        </p>

                        <!-- Trust Badges -->
                        <div class="mt-6 pt-6 border-t space-y-2 text-sm text-gray-600">
                            <div class="flex items-center gap-2">
                                <span>üîí</span>
                                <span>Secure checkout</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <span>‚Ü©Ô∏è</span>
                                <span>Easy returns</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <span>‚úì</span>
                                <span>Quality guaranteed</span>
                            </div>
                        </div>
                    </div>
                </form>
            </div>
        </template>

        <!-- Empty Cart -->
        <template x-if="!loading && !cart">
            <div class="text-center py-20">
                <div class="text-6xl mb-4">üõí</div>
                <h3 class="text-2xl font-bold mb-2">Your cart is empty</h3>
                <p class="text-gray-600 mb-6">Add items before checkout</p>
                <a href="/products/"
                    class="inline-block px-6 py-3 bg-neon text-white rounded-lg hover:bg-green-600 transition font-semibold">
                    Browse Products
                </a>
            </div>
        </template>
    </div>
</div>

<!-- Razorpay Script -->
<script src="https://checkout.razorpay.com/v1/checkout.js"></script>

<script>
    function checkoutPage() {
        return {
            cart: null,
            addresses: [],
            loading: true,
            loading: true,
            placing: false,
            fetchingPincode: false,
            fetchingLocation: false, // New state for geolocation
            selectedAddressId: '',
            paymentMethod: '',
            orderNotes: '',
            useTestPayment: false,
            useTestPayment: false,
            testModeEnabled: true,
            isAuthenticated: !!localStorage.getItem('access_token'),

            // Form State
            address: {
                name: '',
                phone: '',
                address: '',
                city: '',
                state: '',
                postal_code: '',
                landmark: ''
            },

            // Validation Errors
            errors: {
                name: null,
                phone: null,
                address: null,
                city: null,
                state: null,
                postal_code: null
            },

            pincodeStatus: '',

            // Touched state to show errors only after interaction
            touched: {
                name: false,
                phone: false,
                address: false,
                city: false,
                state: false,
                postal_code: false
            },

            cityOptions: [],

            isAutoFilling: false, // Prevents API call when initializing addresses

            walletBalance: 0,
            useWallet: false,

            get isFormValid() {
                // Check if all required fields are filled and have no errors
                const a = this.address;
                // Basic existence check
                if (!a.name || !a.phone || !a.address || !a.city || !a.state || !a.postal_code) return false;

                // Specific constraints (matching schema)
                if (a.name.length < 2 || a.name.length > 200) return false;
                if (a.phone.length > 20 || a.phone.length < 10) return false; // Enforcing reasonable phone min
                if (a.address.length < 5) return false;
                if (a.city.length < 2 || a.city.length > 100) return false;
                if (a.state.length < 2 || a.state.length > 100) return false;
                if (a.postal_code.length !== 6) return false; // Strict 6 digits for India

                return true;
            },

            get walletDeduction() {
                // Deduct min of walletBalance or order subtotal + deliveryCharge (leaving 1 for fee)
                if (!this.useWallet) return 0;
                // We want final payable to be 1 (Fee). 
                // Payable = (Sub + Del + 1) - Deduction.
                // If we want result 1, Deduction must be = (Sub + Del).
                const maxDeductable = parseFloat(this.cart.subtotal) + this.deliveryCharge;
                return Math.min(this.walletBalance, maxDeductable);
            },
            get payableAmount() {
                // Total amount after wallet deduction, minimum 1 for platform fee or test payment 1
                // if (this.useTestPayment) return '1.00'; // This line was commented out in the original
                const total = parseFloat(this.cart.subtotal) + this.deliveryCharge + 1 - this.walletDeduction;
                return (total < 1 ? 1 : total).toFixed(2);
            },
            get deliveryCharge() {
                if (!this.cart) return 0;
                return parseFloat(this.cart.subtotal) >= 500 ? 0 : 40;
            },


            async init() {
                const token = localStorage.getItem('access_token');

                // Remove auto-redirect for guests
                // if (!token) { window.location.href = ... }

                // Setup Watcher for Auto-Payment Logic
                this.$watch('address', (value) => {
                    this.validateAll(false); // Validate silently (update errors if touched)
                    this.handlePaymentAutoSelect();
                }, { deep: true });

                this.$watch('selectedAddressId', () => {
                    this.handlePaymentAutoSelect();
                });

                // Watch for Pincode Changes for Auto-Fetch
                this.$watch('address.postal_code', (val) => {
                    if (this.isAutoFilling) return; // SKIP if auto-filling

                    if (val && val.length === 6) {
                        this.fetchPincodeDetails(val);
                    } else {
                        // Only reset options if user is typing manually
                        this.cityOptions = [];
                    }
                });

                await this.loadWallet();
                await this.fetchCart();
                await this.fetchAddresses();
                await this.fetchUserProfile();
            },

            // ... fetchPincodeDetails, handlePaymentAutoSelect, validateField, validateAll, loadWallet methods remain same ...
            // Optimized Pincode Fetcher with Retry Logic
            // Optimized Pincode Fetcher with Retry Logic
            async fetchPincodeDetails(pincode, attempt = 0) {
                if (this.isAutoFilling) return;

                if (attempt === 0) {
                    this.fetchingPincode = true;
                    this.errors.postal_code = null;
                    this.pincodeStatus = '';
                }

                // Stop recursive madness
                if (attempt > 5) {
                    this.fetchingPincode = false;
                    this.errors.postal_code = "Could not verify pincode automatically. Please enter manually.";
                    this.pincodeStatus = '';
                    return;
                }

                try {
                    const response = await fetch(`https://api.postalpincode.in/pincode/${pincode}`);
                    const data = await response.json();

                    if (data && data[0].Status === "Success") {
                        const postOffices = data[0].PostOffice;

                        // Populate City Options
                        this.cityOptions = postOffices.map(po => po.Name).sort();

                        // Set State
                        if (postOffices[0].State) {
                            this.address.state = postOffices[0].State;
                            this.touched.state = true;
                            this.errors.state = null;
                        }

                        // Auto-select city
                        if (this.cityOptions.length > 0) {
                            this.address.city = this.cityOptions[0];
                            this.touched.city = true;
                            this.errors.city = null;
                        }

                        // If we had to increment/retry
                        if (attempt > 0) {
                            // UPDATE THE FIELD WITH SUCCESSFUL PIN
                            this.address.postal_code = pincode;
                            this.pincodeStatus = `Location found at nearby hub ${pincode}`;

                            // Clear status after 3s
                            setTimeout(() => { this.pincodeStatus = ''; }, 3000);
                        } else {
                            this.pincodeStatus = '';
                        }

                        this.fetchingPincode = false;
                        return;
                    }

                    // If Failed -> RETRY with +1
                    this.pincodeStatus = `Invalid location, checking nearby hub ${parseInt(pincode) + 1}...`;

                    const nextPin = parseInt(pincode) + 1;
                    this.fetchPincodeDetails(nextPin.toString(), attempt + 1);

                } catch (err) {
                    // Fail silently in prod
                    this.fetchingPincode = false;
                    this.pincodeStatus = '';
                }
            },

            async getLocation() {
                if (!navigator.geolocation) {
                    alert('Geolocation is not supported by your browser');
                    return;
                }

                this.fetchingLocation = true;

                navigator.geolocation.getCurrentPosition(
                    async (position) => {
                        const { latitude, longitude } = position.coords;

                        try {
                            // Direct call to Nominatim (Same logic as addresses.html)
                            const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}&addressdetails=1`);

                            // Check content type
                            const contentType = response.headers.get("content-type");
                            if (!contentType || !contentType.includes("json")) {
                                throw new Error("Received non-JSON response from Nominatim");
                            }

                            const data = await response.json();
                            // console.log("Nominatim Checkout Response:", data);

                            if (data && data.address) {
                                const addr = data.address;

                                // Map fields to Checkout Form model
                                this.address.postal_code = addr.postcode || '';

                                // City Priority
                                this.address.city = addr.city || addr.town || addr.village || addr.county || addr.city_district || '';
                                if (this.address.city.length > 50) this.address.city = this.address.city.substring(0, 50);

                                this.address.state = addr.state || '';

                                // Construct Street Address
                                const streetParts = [];
                                if (addr.house_number) streetParts.push(addr.house_number);
                                if (addr.road) streetParts.push(addr.road);
                                if (addr.suburb) streetParts.push(addr.suburb);
                                if (addr.neighbourhood) streetParts.push(addr.neighbourhood);
                                if (addr.residential) streetParts.push(addr.residential);

                                this.address.address = streetParts.filter(Boolean).join(', ').slice(0, 100);
                                this.address.landmark = addr.amenity || addr.landmark || '';

                                // Validate loaded data
                                this.validateAll(true);
                            }
                        } catch (err) {
                            // console.error("Reverse geocoding failed", err);
                            alert('Failed to get address from location');
                        } finally {
                            this.fetchingLocation = false;
                        }
                    },
                    (error) => {
                        // console.error('Geolocation error', error);
                        alert('Unable to retrieve your location. Please check browser permissions.');
                        this.fetchingLocation = false;
                    }
                );
            },

            handlePaymentAutoSelect() {
                if (this.isFormValid) {
                    if (!this.paymentMethod) {
                        this.paymentMethod = 'RAZORPAY';
                    }
                } else {
                    this.paymentMethod = ''; // Deselect if invalid
                }
            },

            validateField(field, markTouched = true) {
                if (markTouched) {
                    this.touched[field] = true;
                }
                const val = this.address[field];

                switch (field) {
                    case 'name':
                        this.errors.name = (val.length < 2 || val.length > 200) ? 'Name must be 2-200 characters' : null;
                        break;
                    case 'phone':
                        // Relaxed but reasonable
                        this.errors.phone = (val.length < 10 || val.length > 20) ? 'Phone must be 10-20 digits' : null;
                        break;
                    case 'address':
                        this.errors.address = (val.length < 5) ? 'Address too short (min 5 chars)' : null;
                        break;
                    case 'city':
                        this.errors.city = (val.length < 2 || val.length > 100) ? 'Invalid city name' : null;
                        break;
                    case 'state':
                        this.errors.state = (val.length < 2 || val.length > 100) ? 'Invalid state name' : null;
                        break;
                    case 'postal_code':
                        this.errors.postal_code = (val.length !== 6) ? 'Pincode must be 6 digits' : null;
                        break;
                }
            },

            validateAll(markTouched = true) {
                if (markTouched) {
                    Object.keys(this.touched).forEach(k => this.touched[k] = true);
                }
                // Run checks
                ['name', 'phone', 'address', 'city', 'state', 'postal_code'].forEach(f => this.validateField(f, markTouched));
            },

            async loadWallet() {
                const token = localStorage.getItem('access_token');
                if (!token) return;
                try {
                    const response = await fetch('/api/wallet/balance', {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    if (response.ok) {
                        const data = await response.json();
                        this.walletBalance = data.balance;
                    }
                } catch (err) {
                    // console.error('Failed to load wallet', err);
                }
            },

            async fetchCart() {
                const token = localStorage.getItem('access_token');

                if (token) {
                    try {
                        const response = await fetch('/api/cart/', {
                            headers: {
                                'Authorization': `Bearer ${token}`
                            }
                        });

                        if (response.ok) {
                            this.cart = await response.json();
                            if (this.cart.items) {
                                this.cart.items = this.cart.items.filter(item => item.is_selected);
                            }
                            if (this.cart.items.length === 0) {
                                this.cart = null;
                            }
                        }
                    } catch (err) {
                        // console.error('Failed to fetch user cart', err);
                    } finally {
                        this.loading = false;
                    }
                } else {
                    // Guest Logic
                    const guestItems = JSON.parse(localStorage.getItem('guest_cart') || '[]');
                    if (guestItems.length > 0) {
                        // Only selected items
                        const selectedItems = guestItems.filter(i => i.is_selected);

                        if (selectedItems.length > 0) {
                            let subtotal = 0;
                            const items = selectedItems.map(item => {
                                const total = parseFloat(item.unit_price) * item.quantity;
                                subtotal += total;
                                return {
                                    id: item.product_id,
                                    product_id: item.product_id,
                                    product_name: item.product_name,
                                    product_slug: item.product_slug,
                                    product_image: item.product_image,
                                    unit_price: item.unit_price,
                                    quantity: item.quantity,
                                    total_price: total.toFixed(2),
                                    is_selected: true
                                };
                            });

                            this.cart = {
                                id: 'guest',
                                items: items,
                                items_count: items.length,
                                subtotal: subtotal.toFixed(2),
                                total: subtotal.toFixed(2) // We'll add delivery logic in getter if needed? 
                                // Actually delivery logic is in 'deliveryCharge' getter which uses this.cart.subtotal
                            };
                        } else {
                            this.cart = null;
                        }
                    } else {
                        this.cart = null;
                    }
                    this.loading = false;
                }
            },

            async fetchAddresses() {
                const token = localStorage.getItem('access_token');
                if (!token) return;
                try {
                    const response = await fetch('/api/auth/addresses', {
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    });

                    if (response.ok) {
                        this.addresses = await response.json();
                    }
                } catch (err) {
                    // console.error('Failed to fetch addresses', err);
                }
            },

            async fetchUserProfile() {
                const token = localStorage.getItem('access_token');
                if (!token) return;

                try {
                    const response = await fetch('/api/auth/me', {
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    });

                    if (response.ok) {
                        const user = await response.json();
                        // console.log('User Profile Fetched:', user); // Debugging phone issue

                        // Pre-fill name and phone if not already filled
                        if (!this.address.name) {
                            this.address.name = user.full_name;
                        }
                        if (!this.address.phone) {
                            this.address.phone = user.phone || '';
                        }
                    }
                } catch (err) {
                    console.error('Failed to fetch user profile', err);
                }
            },

            fillAddressFromSaved() {
                const selected = this.addresses.find(a => a.id === this.selectedAddressId);

                this.isAutoFilling = true; // LOCK API

                if (!selected) {
                    // KEEP name/phone, clear others
                    this.address.address = '';
                    this.address.city = '';
                    this.address.state = '';
                    this.address.postal_code = '';
                    this.address.landmark = '';
                } else {
                    this.address.address = selected.street_address;
                    this.address.city = selected.city;
                    this.address.state = selected.state;
                    this.address.postal_code = selected.postal_code;
                    this.address.landmark = selected.landmark || '';
                    if (selected.phone) this.address.phone = selected.phone;
                }

                // Unlock after delay
                setTimeout(() => { this.isAutoFilling = false; }, 500);
            },

            async placeOrder() {
                this.validateAll(true);

                if (!this.isFormValid) {
                    window.showNotification({
                        type: 'warning',
                        title: 'Invalid Details',
                        message: 'Please fix the errors in the address form.'
                    });
                    this.$el.querySelector('input:invalid, .border-red-500')?.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    return;
                }

                if (!this.paymentMethod) {
                    window.showNotification({
                        type: 'warning',
                        title: 'Select Payment Method',
                        message: 'Please select a payment method'
                    });
                    return;
                }

                this.placing = true;

                const token = localStorage.getItem('access_token');

                try {
                    const response = await fetch('/api/checkout/create', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            delivery_address: {
                                address_id: this.selectedAddressId || null,
                                name: this.address.name,
                                phone: this.address.phone,
                                address: this.address.address,
                                city: this.address.city,
                                state: this.address.state,
                                postal_code: this.address.postal_code,
                                landmark: this.address.landmark
                            },
                            payment_method: this.paymentMethod,
                            order_notes: this.orderNotes,
                            use_wallet: this.useWallet,
                            payable_amount: parseFloat(this.payableAmount)
                        })
                    });

                    const data = await response.json();

                    if (data.success) {
                        if (data.payment_required) {
                            // Open Razorpay
                            this.openRazorpay(data.razorpay_data, data.order_id);
                        } else {
                            // COD - redirect to success page
                            window.location.href = `/order/success/${data.order_id}/`;
                        }
                    } else {
                        window.showNotification({
                            type: 'error',
                            title: 'Order Failed',
                            message: data.message
                        });
                        this.placing = false;
                    }
                } catch (err) {
                    console.error('Failed to place order', err);
                    window.showNotification({
                        type: 'error',
                        title: 'Error',
                        message: 'Failed to place order. Please try again.'
                    });
                    this.placing = false;
                }
            },

            openRazorpay(razorpayData, orderId) {
                const options = {
                    key: razorpayData.key_id,
                    amount: razorpayData.amount,
                    currency: razorpayData.currency,
                    name: 'FarmBasket',
                    description: `Order #${razorpayData.order_number}`,
                    image: '/static/logo.png', // Add your logo here
                    order_id: razorpayData.razorpay_order_id,
                    prefill: {
                        name: razorpayData.customer_name,
                        email: razorpayData.customer_email,
                        contact: razorpayData.customer_phone
                    },
                    theme: {
                        color: '#4ade80'
                    },
                    handler: (response) => {
                        // Payment successful
                        this.verifyPayment(orderId, response);
                    },
                    modal: {
                        ondismiss: () => {
                            // Payment cancelled
                            this.placing = false;
                            window.showNotification({
                                type: 'warning',
                                title: 'Payment Cancelled',
                                message: 'You cancelled the payment. Your order is still pending.'
                            });
                        }
                    }
                };

                const rzp = new Razorpay(options);
                rzp.open();
            },

            async verifyPayment(orderId, razorpayResponse) {
                const token = localStorage.getItem('access_token');

                try {
                    const response = await fetch('/api/payment/verify', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            order_id: orderId,
                            razorpay_order_id: razorpayResponse.razorpay_order_id,
                            razorpay_payment_id: razorpayResponse.razorpay_payment_id,
                            razorpay_signature: razorpayResponse.razorpay_signature
                        })
                    });

                    const data = await response.json();

                    if (data.success) {
                        // Payment verified - redirect to success page
                        window.location.href = `/order/success/${orderId}/`;
                    } else {
                        window.showNotification({
                            type: 'error',
                            title: 'Payment Verification Failed',
                            message: data.message
                        });
                        this.placing = false;
                    }
                } catch (err) {
                    console.error('Failed to verify payment', err);
                    window.showNotification({
                        type: 'error',
                        title: 'Error',
                        message: 'Payment verification failed. Please contact support.'
                    });
                    this.placing = false;
                }
            }
        }
    }
</script>
{% endblock %}